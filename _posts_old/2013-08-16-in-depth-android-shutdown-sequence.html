---
layout: post
title: 'In Depth : Android Shutdown Sequence'
date: '2013-08-16T13:25:00.000+05:30'
author: Ketan Parmar
tags:
- shutdown sequence
- android shutdown sequence
- Android
modified_time: '2013-08-16T13:25:30.195+05:30'
thumbnail: http://2.bp.blogspot.com/-CDQYezZLG8M/Ugxr7BWTuQI/AAAAAAAAERE/a1VxeuIEZbA/s72-c/Android+Shutdown+Sequence.jpg
blogger_id: tag:blogger.com,1999:blog-17114597.post-6095205531599844100
blogger_orig_url: http://www.kpbird.com/2013/08/in-depth-android-shutdown-sequence.html
---

<span style="font-family: Verdana, sans-serif;"><br /></span><span style="font-family: Verdana, sans-serif;">What happened when I long press power button ?</span><br /><span style="font-family: Verdana, sans-serif;">What is shutdown sequence ?</span><br /><span style="font-family: Verdana, sans-serif;">How is it different from desktop linux shutdown sequence?</span><br /><span style="font-family: Verdana, sans-serif;">How to change shutdown menu ?</span><br /><br /><span style="font-family: Verdana, sans-serif;">Many questions pop-up in mind when we think about Android shutdown sequence. Before you read about shutdown sequence I suggest you to read about<a href="http://www.kpbird.com/2012/11/in-depth-android-boot-sequence-process.html"> boot sequence article</a>.</span><br /><span style="font-family: Verdana, sans-serif; font-size: x-small;"><br /></span><br /><div style="text-align: justify;"><span style="font-family: Verdana, sans-serif;">Android is linux based open source operating system, x86 (x86 is a series of computer microprocessor instruction set architectures based on the Intel 8086 CPU.) is most likely system where linux kernel is deployed however all Android devices are running on ARM process (ARM (formerly Advanced RISC Machine, which was formerly Acorn RISC Machine)) except Intelâ€™s Xolo device (<a href="http://xolo.in/xolo-x900-features">http://xolo.in/xolo-x900-features</a>). Xolo comes with Atom 1.6 GHz x86 processor. Android shutdown sequence is different from desktop linux like ubuntu, fedora, etc. &nbsp;</span><br /><span style="font-family: Verdana, sans-serif;">In this article I am going to explain shutdown sequence for Android only. Please refer <a href="http://www.techrepublic.com/article/customizing-the-linux-bootup-and-shutdown-processes/">"Linux Boot and Shutdown Process"</a> for details of desktop linux shutdown process.</span><br /><span style="font-family: Verdana, sans-serif;"><br /></span><span style="font-family: Verdana, sans-serif;">Following diagram&nbsp;illustrate shutdown sequence in detail.</span></div><div style="text-align: justify;"><span style="font-family: Verdana, sans-serif;"><br /></span><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-CDQYezZLG8M/Ugxr7BWTuQI/AAAAAAAAERE/a1VxeuIEZbA/s1600/Android+Shutdown+Sequence.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span style="font-family: Verdana, sans-serif;"><img border="0" height="640" src="http://2.bp.blogspot.com/-CDQYezZLG8M/Ugxr7BWTuQI/AAAAAAAAERE/a1VxeuIEZbA/s640/Android+Shutdown+Sequence.jpg" width="608" /></span></a></div><span style="font-family: Verdana, sans-serif;"><br /></span></div><div style="text-align: justify;"><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;"><b>Step 1:</b> Long Press Power Button for 500ms.</span></div><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;"><b>Step 2:</b> PhoneWindowManager.java identify Power Button long press and call method named "interceptKeyBeforeQueueing".&nbsp;</span></div><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;">Following code display power key &nbsp;snippet from the function.</span></div><span style="font-family: Verdana, sans-serif;"><br /></span><br /><pre class="brush:java">/** {@inheritDoc} */<br />@Override<br />public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags, boolean isScreenOn) {<br />....<br />....<br />....<br />case KeyEvent.KEYCODE_POWER: {<br />     result &amp;= ~ACTION_PASS_TO_USER;<br />       if (down) {<br />         if (isScreenOn &amp;&amp; !mPowerKeyTriggered<br />               &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {<br />                   mPowerKeyTriggered = true;<br />                   mPowerKeyTime = event.getDownTime();<br />                   interceptScreenshotChord();<br />            }<br />               ITelephony telephonyService = getTelephonyService();<br />                boolean hungUp = false;<br />               if (telephonyService != null) {<br />                   try {<br />                       if (telephonyService.isRinging()) {<br />                           // Pressing Power while there's a ringing incoming<br />                           // call should silence the ringer.<br />                            telephonyService.silenceRinger();<br />                       } else if ((mIncallPowerBehavior<br />                                &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0<br />                               &amp;&amp; telephonyService.isOffhook()) {<br />                            // Otherwise, if "Power button ends call" is enabled,<br />                           // the Power button will hang up any current active call.<br />                            hungUp = telephonyService.endCall();<br />                       }<br />                   } catch (RemoteException ex) {<br />                        Log.w(TAG, "ITelephony threw RemoteException", ex);<br />                   }<br />               }<br />               interceptPowerKeyDown(!isScreenOn || hungUp<br />                       || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);<br />           } else {<br />               mPowerKeyTriggered = false;<br />               cancelPendingScreenshotChordAction();<br />               if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {<br />                   result = (result &amp; ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;<br />               }<br />               mPendingPowerKeyUpCanceled = false;<br />           }<br />          break;<br />      }<br />....<br />....<br />....<br />}<br /></pre><span style="font-family: Verdana, sans-serif;"><br /></span><br /><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;">Above code handle multiple options like silence ringtone, take screenshots and power off. It will identify&nbsp;appropriate option based on time duration and other key's status. It will call "interceptPowerKeyDown" option by&nbsp;eliminate other options.</span></div><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;"><br /></span></div><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;">Following code display interceptPowerKeyDown function. It will wait for 500 millisecond&nbsp;</span><span style="font-family: Verdana, sans-serif;">(ViewConfiguration#getGlobalActionKeyTimeout())</span><span style="font-family: Verdana, sans-serif;">&nbsp;then call mPowerLongPress Thread.</span></div><span style="font-family: Verdana, sans-serif;"><br /></span><br /><pre class="brush:java">private void interceptPowerKeyDown(boolean handled) {<br />  mPowerKeyHandled = handled;<br />  if (!handled) {<br />       mHandler.postDelayed(mPowerLongPress, ViewConfiguration.getGlobalActionKeyTimeout());<br />  }<br />}<br /></pre><span style="font-family: Verdana, sans-serif;">Following code represent mPowerLongPress thread</span><br /><pre class="brush:java">private final Runnable mPowerLongPress = new Runnable() {<br />        @Override<br />        public void run() {<br />            // The context isn't read<br />            if (mLongPressOnPowerBehavior &lt; 0) {<br />                mLongPressOnPowerBehavior = mContext.getResources().getInteger(<br />                        com.android.internal.R.integer.config_longPressOnPowerBehavior);<br />            }<br />            int resolvedBehavior = mLongPressOnPowerBehavior;<br />            if (FactoryTest.isLongPressOnPowerOffEnabled()) {<br />                resolvedBehavior = LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM;<br />            }<br /><br />            switch (resolvedBehavior) {<br />            case LONG_PRESS_POWER_NOTHING:<br />                break;<br />            case LONG_PRESS_POWER_GLOBAL_ACTIONS:<br />                mPowerKeyHandled = true;<br />                if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) {<br />                    performAuditoryFeedbackForAccessibilityIfNeed();<br />                }<br />                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);<br />                showGlobalActionsDialog();<br />                break;<br />            case LONG_PRESS_POWER_SHUT_OFF:<br />            case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:<br />                mPowerKeyHandled = true;<br />                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);<br />                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);<br />                mWindowManagerFuncs.shutdown(resolvedBehavior == LONG_PRESS_POWER_SHUT_OFF);<br />                break;<br />            }<br />        }<br />    };<br /></pre><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;"><b>Step 3:</b> Controls goes to GlobalActions.java which is responsible to display dialogbox with various options like (Power Off, Airplan mode, Take screenshot and few toggle buttons), This dialog box has different options are per your OEM provider, model and Android OS version. GlobalAction class has method named showdialog() which is responsible to create object of Dialogbox with options.</span></div><pre class="brush:java">void showGlobalActionsDialog() {<br />    if (mGlobalActions == null) {<br />        mGlobalActions = new GlobalActions(mContext, mWindowManagerFuncs);<br />    }<br />    final boolean keyguardShowing = keyguardIsShowingTq();<br />    mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned());<br />    if (keyguardShowing) {<br />         // since it took two seconds of long press to bring this up,<br />        // poke the wake lock so they have some time to see the dialog.<br />        mKeyguardMediator.userActivity();<br />    }<br />}<br /></pre><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-4xFMLrjRTmo/Ug22onfMttI/AAAAAAAAERc/FLFzZBalKPY/s1600/Screenshot_2013-08-16-10-47-09.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://1.bp.blogspot.com/-4xFMLrjRTmo/Ug22onfMttI/AAAAAAAAERc/FLFzZBalKPY/s400/Screenshot_2013-08-16-10-47-09.png" width="225" /></a></div><span style="font-family: Verdana, sans-serif;"><br /></span><span style="font-family: Verdana, sans-serif;"><br /></span><br /><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;"><b>Step 4:</b> If user select "Power Off" option from the dialogbox then control again goes back to PhoneWindowManager, It will start shutdown process.</span></div><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;"><b>Step 5:</b> Shutdown process initiate from ShutdownThread.java file's shoutdowninner() function, It wil display confirmation dialog with ok / cancel button, If user select ok option then actual shutdown process starts.</span></div><span style="font-family: Verdana, sans-serif;"><br /></span><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-ucHfCwmrBCw/Ug223yE7B0I/AAAAAAAAERk/WEGN5-Pj35U/s1600/Screenshot_2013-08-16-10-47-29.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://2.bp.blogspot.com/-ucHfCwmrBCw/Ug223yE7B0I/AAAAAAAAERk/WEGN5-Pj35U/s400/Screenshot_2013-08-16-10-47-29.png" width="225" /></a></div><div style="text-align: left;"><span style="font-family: Verdana, sans-serif;"><b>Step 6:</b> beginShutdownSequence() function called when user select OK option from the dialog.</span></div><span style="font-family: Verdana, sans-serif;"><br /></span><br /><pre class="brush:java">private static void beginShutdownSequence(Context context) {<br />        synchronized (sIsStartedGuard) {<br />            if (sIsStarted) {<br />                Log.d(TAG, "Shutdown sequence already running, returning.");<br />                return;<br />            }<br />            sIsStarted = true;<br />        }<br /><br />        // throw up an indeterminate system dialog to indicate radio is<br />        // shutting down.<br />        ProgressDialog pd = new ProgressDialog(context);<br />        pd.setTitle(context.getText(com.android.internal.R.string.power_off));<br />        pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));<br />        pd.setIndeterminate(true);<br />        pd.setCancelable(false);<br />        pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);<br /><br />        pd.show();<br /><br />        sInstance.mContext = context;<br />        sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE);<br /><br />        // make sure we never fall asleep again<br />        sInstance.mCpuWakeLock = null;<br />        try {<br />            sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock(<br />                    PowerManager.PARTIAL_WAKE_LOCK, TAG + "-cpu");<br />            sInstance.mCpuWakeLock.setReferenceCounted(false);<br />            sInstance.mCpuWakeLock.acquire();<br />        } catch (SecurityException e) {<br />            Log.w(TAG, "No permission to acquire wake lock", e);<br />            sInstance.mCpuWakeLock = null;<br />        }<br /><br />        // also make sure the screen stays on for better user experience<br />        sInstance.mScreenWakeLock = null;<br />        if (sInstance.mPowerManager.isScreenOn()) {<br />            try {<br />                sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock(<br />                        PowerManager.FULL_WAKE_LOCK, TAG + "-screen");<br />                sInstance.mScreenWakeLock.setReferenceCounted(false);<br />                sInstance.mScreenWakeLock.acquire();<br />            } catch (SecurityException e) {<br />                Log.w(TAG, "No permission to acquire wake lock", e);<br />                sInstance.mScreenWakeLock = null;<br />            }<br />        }<br /><br />        // start the thread that initiates shutdown<br />        sInstance.mHandler = new Handler() {<br />        };<br />        sInstance.start();<br />    }</pre><span style="font-family: Verdana, sans-serif;"><b>Run method, start actual shutdown process&nbsp;</b></span><br /><pre class="brush:java"> public void run() {<br />        BroadcastReceiver br = new BroadcastReceiver() {<br />            @Override public void onReceive(Context context, Intent intent) {<br />                // We don't allow apps to cancel this, so ignore the result.<br />                actionDone();<br />            }<br />        };<br /><br />        /*<br />         * Write a system property in case the system_server reboots before we<br />         * get to the actual hardware restart. If that happens, we'll retry at<br />         * the beginning of the SystemServer startup.<br />         */<br />        {<br />            String reason = (mReboot ? "1" : "0") + (mRebootReason != null ? mRebootReason : "");<br />            SystemProperties.set(SHUTDOWN_ACTION_PROPERTY, reason);<br />        }<br /><br />        /*<br />         * If we are rebooting into safe mode, write a system property<br />         * indicating so.<br />         */<br />        if (mRebootSafeMode) {<br />            SystemProperties.set(REBOOT_SAFEMODE_PROPERTY, "1");<br />        }<br /><br />        Log.i(TAG, "Sending shutdown broadcast...");<br />        <br />        // First send the high-level shut down broadcast.<br />        mActionDone = false;<br />        Intent intent = new Intent(Intent.ACTION_SHUTDOWN);<br />        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);<br />        mContext.sendOrderedBroadcastAsUser(intent,<br />                UserHandle.ALL, null, br, mHandler, 0, null, null);<br />        <br />        final long endTime = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;<br />        synchronized (mActionDoneSync) {<br />            while (!mActionDone) {<br />                long delay = endTime - SystemClock.elapsedRealtime();<br />                if (delay &lt;= 0) {<br />                    Log.w(TAG, "Shutdown broadcast timed out");<br />                    break;<br />                }<br />                try {<br />                    mActionDoneSync.wait(delay);<br />                } catch (InterruptedException e) {<br />                }<br />            }<br />        }<br />        <br />        Log.i(TAG, "Shutting down activity manager...");<br />        <br />        final IActivityManager am =<br />            ActivityManagerNative.asInterface(ServiceManager.checkService("activity"));<br />        if (am != null) {<br />            try {<br />                am.shutdown(MAX_BROADCAST_TIME);<br />            } catch (RemoteException e) {<br />            }<br />        }<br /><br />        // Shutdown radios.<br />        shutdownRadios(MAX_RADIO_WAIT_TIME);<br /><br />        // Shutdown MountService to ensure media is in a safe state<br />        IMountShutdownObserver observer = new IMountShutdownObserver.Stub() {<br />            public void onShutDownComplete(int statusCode) throws RemoteException {<br />                Log.w(TAG, "Result code " + statusCode + " from MountService.shutdown");<br />                actionDone();<br />            }<br />        };<br /><br />        Log.i(TAG, "Shutting down MountService");<br /><br />        // Set initial variables and time out time.<br />        mActionDone = false;<br />        final long endShutTime = SystemClock.elapsedRealtime() + MAX_SHUTDOWN_WAIT_TIME;<br />        synchronized (mActionDoneSync) {<br />            try {<br />                final IMountService mount = IMountService.Stub.asInterface(<br />                        ServiceManager.checkService("mount"));<br />                if (mount != null) {<br />                    mount.shutdown(observer);<br />                } else {<br />                    Log.w(TAG, "MountService unavailable for shutdown");<br />                }<br />            } catch (Exception e) {<br />                Log.e(TAG, "Exception during MountService shutdown", e);<br />            }<br />            while (!mActionDone) {<br />                long delay = endShutTime - SystemClock.elapsedRealtime();<br />                if (delay &lt;= 0) {<br />                    Log.w(TAG, "Shutdown wait timed out");<br />                    break;<br />                }<br />                try {<br />                    mActionDoneSync.wait(delay);<br />                } catch (InterruptedException e) {<br />                }<br />            }<br />        }<br /><br />        rebootOrShutdown(mReboot, mRebootReason);<br />    }<br /></pre><span style="font-family: Verdana, sans-serif;"><br /></span><span style="font-family: Verdana, sans-serif;"><b>Step 7:</b> With rebootOrShutdown() method controls transfer to the native function of com_android_server_power_PowerManagerService.cpp file, and finally control goes to android_reboot.c file which is final step of shutdown sequence.</span><br /><pre class="brush:cpp">static void nativeShutdown(JNIEnv *env, jclass clazz) {<br />    android_reboot(ANDROID_RB_POWEROFF, 0, 0);<br />}<br /></pre><span style="font-family: Verdana, sans-serif;"><br /></span><span style="font-family: Verdana, sans-serif;"><b>References</b></span><br /><ol><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java"><span style="font-family: Verdana, sans-serif;">PhoneWindowManager.java</span></a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/policy/src/com/android/internal/policy/impl/GlobalActions.java"><span style="font-family: Verdana, sans-serif;">GlobalActions.java</span></a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/WindowManagerPolicy.java"><span style="font-family: Verdana, sans-serif;">WindowManagerPolicy.java</span></a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/java/com/android/server/power/ShutdownThread.java"><span style="font-family: Verdana, sans-serif;">ShutdownThread.java</span></a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/java/com/android/server/power/PowerManagerService.java"><span style="font-family: Verdana, sans-serif;">PowerManagerService.java</span></a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/jni/com_android_server_power_PowerManagerService.cpp"><span style="font-family: Verdana, sans-serif;">com_android_server_power_PowerManagerService.cpp</span></a></li><li><a href="https://android.googlesource.com/platform/system/core/+/master/libcutils/android_reboot.c"><span style="font-family: Verdana, sans-serif;">android_reboot.c</span></a></li><li><a href="http://www.techrepublic.com/article/customizing-the-linux-bootup-and-shutdown-processes/"><span style="font-family: Verdana, sans-serif;">Linux Boot and Shutdown Process</span></a></li></ol><span style="font-family: Verdana, sans-serif;"><br /></span></div>