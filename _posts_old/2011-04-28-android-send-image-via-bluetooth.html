---
layout: post
title: 'Android: Send Image via Bluetooth'
date: '2011-04-28T14:20:00.000+05:30'
author: Ketan Parmar
tags:
- Android
- Bluetooth
modified_time: '2013-03-16T16:27:02.635+05:30'
blogger_id: tag:blogger.com,1999:blog-17114597.post-914713126653160942
blogger_orig_url: http://www.kpbird.com/2011/04/android-send-image-via-bluetooth.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">I assume that you have experience of developing Bluetooth application in Android. Android Bluetooth API &nbsp;is not supporting OBEX directly, means I can not push any file directly to any device. Android Bluetooth API provide basic functionalities like discovery, connection and data transfer using streams (InputStream and OutputStream).<br /><br />Transferring file using Bluetooth need lot of coding. We need to manage device&nbsp;discovery,&nbsp;connection, IO etc.<br /><br />Now I found very simple way to send file using Bluetooth. Android has build-in Bluetooth application which allow us to send file&nbsp;across the devices. &nbsp;Build-in Bluetooth Application use SharedPerference to manage queue for Incoming and Outgoing files.<br /><br />I find the way to use same technique. Android Bluetooth application use ContentProvider to manage communication between storage and user interface. so I found the way that we can use it's&nbsp;functionality&nbsp; <br /><br />Here is the code, Following 6 line allow you to send file using bluetooth, &nbsp;you required only two things 1. URI of file which you want to send 2. DeviceAddress.<br /><br /><style type="text/css">p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Menlo} span.s1 {color: #b92e9f} span.s2 {color: #cf2b23} span.Apple-tab-span {white-space:pre} </style>   <br /><div class="p1"><br /><ol style="text-align: left;"><li>ContentValues values = <span class="s1">new</span> ContentValues();</li><li>values.put(BluetoothShare.URI, <span class="s2">"content://"</span> + <b>uritoSend</b>);</li><li>values.put(BluetoothShare.DESTINATION, <b>deviceAddress</b>);</li><li>values.put(BluetoothShare.DIRECTION, BluetoothShare.DIRECTION_OUTBOUND);</li><li>Long ts = System.currentTimeMillis();</li><li>values.put(BluetoothShare.TIMESTAMP, ts);</li></ol></div><div class="p1">Description of above code.<br />1. Create object of ContentValue<br />2. put URI of file which you want to send<br />3. put DeviceAdddress, destination device address<br />4. put Direction, set outbound means you want to send the file.<br />5. time stamp which will display at Notification bar<br />6. put time stamp.<br /><br />Note: Above code is useful only if we can have URI of file which we want to send. It is perfectly work for Images because we can get URI of images available in Gallery but If we want to send file from SDCard then it&nbsp;difficult because we can not get URI of file available in SDCard.<br /><br />BluetoothShare.java<br /><pre class="brush:java">import android.provider.BaseColumns;<br />import android.net.Uri;<br /><br />/**<br /> * Exposes constants used to interact with the Bluetooth Share manager's content<br /> * provider.<br /> */<br /><br />public final class BluetoothShare implements BaseColumns {<br />private BluetoothShare() {<br />}<br />/**<br /> * The permission to access the Bluetooth Share Manager<br /> */<br />public static final String PERMISSION_ACCESS = "android.permission.ACCESS_BLUETOOTH_SHARE";<br /><br />/**<br /> * The content:// URI for the data table in the provider<br /> */<br />public static final Uri CONTENT_URI = Uri.parse("content://com.android.bluetooth.opp/btopp");<br /><br />/**<br /> * Broadcast Action: this is sent by the Bluetooth Share component to<br /> * transfer complete. The request detail could be retrieved by app * as _ID<br /> * is specified in the intent's data.<br /> */<br />public static final String TRANSFER_COMPLETED_ACTION = "android.btopp.intent.action.TRANSFER_COMPLETE";<br /><br />/**<br /> * This is sent by the Bluetooth Share component to indicate there is an<br /> * incoming file need user to confirm.<br /> */<br />public static final String INCOMING_FILE_CONFIRMATION_REQUEST_ACTION = "android.btopp.intent.action.INCOMING_FILE_NOTIFICATION";<br /><br />/**<br /> * This is sent by the Bluetooth Share component to indicate there is an<br /> * incoming file request timeout and need update UI.<br /> */<br />public static final String USER_CONFIRMATION_TIMEOUT_ACTION = "android.btopp.intent.action.USER_CONFIRMATION_TIMEOUT";<br /><br />/**<br /> * The name of the column containing the URI of the file being<br /> * sent/received.<br /> */<br />public static final String URI = "uri";<br /><br />/**<br /> * The name of the column containing the filename that the incoming file<br /> * request recommends. When possible, the Bluetooth Share manager will<br /> * attempt to use this filename, or a variation, as the actual name for the<br /> * file.<br /> */<br />public static final String FILENAME_HINT = "hint";<br /><br />/**<br /> * The name of the column containing the filename where the shared file was<br /> * actually stored.<br /> */<br />public static final String _DATA = "_data";<br /><br />/**<br /> * The name of the column containing the MIME type of the shared file.<br /> */<br />public static final String MIMETYPE = "mimetype";<br /><br />/**<br /> * The name of the column containing the direction (Inbound/Outbound) of the<br /> * transfer. See the DIRECTION_* constants for a list of legal values.<br /> */<br />public static final String DIRECTION = "direction";<br /><br />/**<br /> * The name of the column containing Bluetooth Device Address that the<br /> * transfer is associated with.<br /> */<br />public static final String DESTINATION = "destination";<br /><br />/**<br /> * The name of the column containing the flags that controls whether the<br /> * transfer is displayed by the UI. See the VISIBILITY_* constants for a<br /> * list of legal values.<br /> */<br />public static final String VISIBILITY = "visibility";<br /><br />/**<br /> * The name of the column containing the current user confirmation state of<br /> * the transfer. Applications can write to this to confirm the transfer. the<br /> * USER_CONFIRMATION_* constants for a list of legal values.<br /> */<br />public static final String USER_CONFIRMATION = "confirm";<br /><br />/**<br /> * The name of the column containing the current status of the transfer.<br /> * Applications can read this to follow the progress of each download. See<br /> * the STATUS_* constants for a list of legal values.<br /> */<br />public static final String STATUS = "status";<br /><br />/**<br /> * The name of the column containing the total size of the file being<br /> * transferred.<br /> */<br />public static final String TOTAL_BYTES = "total_bytes";<br /><br />/**<br /> * The name of the column containing the size of the part of the file that<br /> * has been transferred so far.<br /> */<br />public static final String CURRENT_BYTES = "current_bytes";<br /><br />/**<br /> * The name of the column containing the timestamp when the transfer is<br /> * initialized.<br /> */<br />public static final String TIMESTAMP = "timestamp";<br /><br />/**<br /> * This transfer is outbound, e.g. share file to other device.<br /> */<br />public static final int DIRECTION_OUTBOUND = 0;<br /><br />/**<br /> * This transfer is inbound, e.g. receive file from other device.<br /> */<br />public static final int DIRECTION_INBOUND = 1;<br /><br />/**<br /> * This transfer is waiting for user confirmation.<br /> */<br />public static final int USER_CONFIRMATION_PENDING = 0;<br /><br />/**<br /> * This transfer is confirmed by user.<br /> */<br />public static final int USER_CONFIRMATION_CONFIRMED = 1;<br /><br />/**<br /> * This transfer is auto-confirmed per previous user confirmation.<br /> */<br />public static final int USER_CONFIRMATION_AUTO_CONFIRMED = 2;<br /><br />/**<br /> * This transfer is denied by user.<br /> */<br />public static final int USER_CONFIRMATION_DENIED = 3;<br /><br />/**<br /> * This transfer is timeout before user action.<br /> */<br />public static final int USER_CONFIRMATION_TIMEOUT = 4;<br /><br />/**<br /> * This transfer is visible and shows in the notifications while in progress<br /> * and after completion.<br /> */<br />public static final int VISIBILITY_VISIBLE = 0;<br /><br />/**<br /> * This transfer doesn't show in the notifications.<br /> */<br />public static final int VISIBILITY_HIDDEN = 1;<br /><br />/**<br /> * Returns whether the status is informational (i.e. 1xx).<br /> */<br />public static boolean isStatusInformational(int status) {<br />    return (status &gt;= 100 &amp;&amp; status &lt; 200);<br />}<br /><br />/**<br /> * Returns whether the transfer is suspended. (i.e. whether the transfer<br /> * won't complete without some action from outside the transfer manager).<br /> */<br />public static boolean isStatusSuspended(int status) {<br />    return (status == STATUS_PENDING);<br />}<br /><br />/**<br /> * Returns whether the status is a success (i.e. 2xx).<br /> */<br />public static boolean isStatusSuccess(int status) {<br />    return (status &gt;= 200 &amp;&amp; status &lt; 300);<br />}<br /><br />/**<br /> * Returns whether the status is an error (i.e. 4xx or 5xx).<br /> */<br />public static boolean isStatusError(int status) {<br />    return (status &gt;= 400 &amp;&amp; status &lt; 600);<br />}<br /><br />/**<br /> * Returns whether the status is a client error (i.e. 4xx).<br /> */<br />public static boolean isStatusClientError(int status) {<br />    return (status &gt;= 400 &amp;&amp; status &lt; 500);<br />}<br /><br />/**<br /> * Returns whether the status is a server error (i.e. 5xx).<br /> */<br />public static boolean isStatusServerError(int status) {<br />    return (status &gt;= 500 &amp;&amp; status &lt; 600);<br />}<br /><br />/**<br /> * Returns whether the transfer has completed (either with success or<br /> * error).<br /> */<br />public static boolean isStatusCompleted(int status) {<br />    return (status &gt;= 200 &amp;&amp; status &lt; 300) || (status &gt;= 400 &amp;&amp; status &lt; 600);<br />}<br /><br />/**<br /> * This transfer hasn't stated yet<br /> */<br />public static final int STATUS_PENDING = 190;<br /><br />/**<br /> * This transfer has started<br /> */<br />public static final int STATUS_RUNNING = 192;<br /><br />/**<br /> * This transfer has successfully completed. Warning: there might be other<br /> * status values that indicate success in the future. Use isSucccess() to<br /> * capture the entire category.<br /> */<br />public static final int STATUS_SUCCESS = 200;<br /><br />/**<br /> * This request couldn't be parsed. This is also used when processing<br /> * requests with unknown/unsupported URI schemes.<br /> */<br />public static final int STATUS_BAD_REQUEST = 400;<br /><br />/**<br /> * This transfer is forbidden by target device.<br /> */<br />public static final int STATUS_FORBIDDEN = 403;<br /><br />/**<br /> * This transfer can't be performed because the content cannot be handled.<br /> */<br />public static final int STATUS_NOT_ACCEPTABLE = 406;<br /><br />/**<br /> * This transfer cannot be performed because the length cannot be determined<br /> * accurately. This is the code for the HTTP error "Length Required", which<br /> * is typically used when making requests that require a content length but<br /> * don't have one, and it is also used in the client when a response is<br /> * received whose length cannot be determined accurately (therefore making<br /> * it impossible to know when a transfer completes).<br /> */<br />public static final int STATUS_LENGTH_REQUIRED = 411;<br /><br />/**<br /> * This transfer was interrupted and cannot be resumed. This is the code for<br /> * the OBEX error "Precondition Failed", and it is also used in situations<br /> * where the client doesn't have an ETag at all.<br /> */<br />public static final int STATUS_PRECONDITION_FAILED = 412;<br /><br />/**<br /> * This transfer was canceled<br /> */<br />public static final int STATUS_CANCELED = 490;<br /><br />/**<br /> * This transfer has completed with an error. Warning: there will be other<br /> * status values that indicate errors in the future. Use isStatusError() to<br /> * capture the entire category.<br /> */<br />public static final int STATUS_UNKNOWN_ERROR = 491;<br /><br />/**<br /> * This transfer couldn't be completed because of a storage issue.<br /> * Typically, that's because the file system is missing or full.<br /> */<br />public static final int STATUS_FILE_ERROR = 492;<br /><br />/**<br /> * This transfer couldn't be completed because of no sdcard.<br /> */<br />public static final int STATUS_ERROR_NO_SDCARD = 493;<br /><br />/**<br /> * This transfer couldn't be completed because of sdcard full.<br /> */<br />public static final int STATUS_ERROR_SDCARD_FULL = 494;<br /><br />/**<br /> * This transfer couldn't be completed because of an unspecified un-handled<br /> * OBEX code.<br /> */<br />public static final int STATUS_UNHANDLED_OBEX_CODE = 495;<br /><br />/**<br /> * This transfer couldn't be completed because of an error receiving or<br /> * processing data at the OBEX level.<br /> */<br />public static final int STATUS_OBEX_DATA_ERROR = 496;<br /><br />/**<br /> * This transfer couldn't be completed because of an error when establishing<br /> * connection.<br /> */<br />public static final int STATUS_CONNECTION_ERROR = 497;<br /><br />}<br /></pre><br /><br />AndroidManifast.xml<br /><pre class="brush:xml">&lt;uses-permission android:name="android.permission.BLUETOOTH"/&gt;<br /><br />&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt;<br /><br /><br /><br /></pre><br /><br /><br /><br /><br /></div></div>